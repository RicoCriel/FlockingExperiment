#pragma kernel CSMain
struct BoidData
{
    float3 position;
    float3 velocity;
};

RWStructuredBuffer<BoidData> boidsBuffer;
float deltaTime;
float3 tankCenter;
float3 tankExtents;

float neighbourDistance;
float minSpeed;
float maxSpeed;
float separationWeight;
float alignmentWeight;
float cohesionWeight;
float rotationSpeed;
float viewingAngle;
int boidCount;

[numthreads(256, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{
    if (id >= boidCount)
        return;

    BoidData self = boidsBuffer[id];

    float3 separation = 0;
    float3 alignment = 0;
    float3 cohesion = 0;
    int count = 0;
    int avoidCount = 0;
    float speedSum = 0;

    for (uint i = 0; i < boidCount; i++)
    {
        if (i == id)
            continue;
        BoidData other = boidsBuffer[i];
        float3 toOther = other.position - self.position;
        float distSqr = dot(toOther, toOther);

        if (distSqr <= neighbourDistance * neighbourDistance)
        {
            float3 forward = normalize(self.velocity);
            float angle = degrees(acos(dot(forward, normalize(toOther))));

            if (angle <= viewingAngle * 0.5f)
            {
                // Separation
                if (distSqr < 1.0f)
                {
                    separation -= normalize(toOther);
                    avoidCount++;
                }

                // Alignment
                alignment += normalize(other.velocity);
                // Cohesion
                cohesion += other.position;

                speedSum += length(other.velocity);
                count++;
            }
        }
    }

    float3 finalDir = 0;
    if (count > 0)
    {
        alignment = normalize(alignment / count);
        cohesion = normalize((cohesion / count) - self.position);
        finalDir += alignment * alignmentWeight + cohesion * cohesionWeight;
    }

    if (avoidCount > 0)
    {
        separation = normalize(separation / avoidCount);
        finalDir += separation * separationWeight;
    }

    // Boundary check
    float3 minBounds = tankCenter - tankExtents;
    float3 maxBounds = tankCenter + tankExtents;
    if (any(self.position < minBounds) || any(self.position > maxBounds))
    {
        float3 toCenter = normalize(tankCenter - self.position);
        finalDir += toCenter * 2.0f; // Strong boundary influence
    }

    if (length(finalDir) > 0)
    {
        float3 currentDir = normalize(self.velocity);
        finalDir = normalize(lerp(currentDir, finalDir, rotationSpeed * deltaTime));
    }
    else
    {
        finalDir = normalize(self.velocity);
    }

    // Speed adjustment
    float speed = length(self.velocity);
    if (count > 0)
    {
        float avgSpeed = speedSum / count;
        speed = clamp(avgSpeed, minSpeed, maxSpeed);
    }
    else
    {
        speed = clamp(speed, minSpeed, maxSpeed);
    }

    self.velocity = finalDir * speed;
    self.position += self.velocity * deltaTime;

    boidsBuffer[id] = self;
}